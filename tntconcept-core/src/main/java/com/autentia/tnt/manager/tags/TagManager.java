/**
 * TNTConcept Easy Enterprise Management by Autentia Real Bussiness Solution S.L.
 * Copyright (C) 2007 Autentia Real Bussiness Solution S.L.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package com.autentia.tnt.manager.tags;

import com.autentia.tnt.businessobject.Contact;

import java.util.Collection;
import java.util.List;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.autentia.tnt.businessobject.Position;
import com.autentia.tnt.businessobject.Tag;
import com.autentia.tnt.dao.SortCriteria;
import com.autentia.tnt.dao.hibernate.ContactDAO;
import com.autentia.tnt.dao.hibernate.TagDAO;
import com.autentia.tnt.dao.search.TagSearch;
import com.autentia.tnt.manager.contacts.ContactManager;
import com.autentia.tnt.manager.contacts.PositionManager;
import com.autentia.tnt.tracking.EntityChange;
import com.autentia.tnt.tracking.hibernate.dao.EntityChangeDAO;
import com.autentia.tnt.util.HibernateUtil;
import com.autentia.tnt.util.SpringUtils;

public class TagManager {

/* Tag - generated by stajanov (do not edit/delete) */

  /** Logger */
  private static final Log log = LogFactory.getLog(TagManager.class);

  /** Tag DAO **/
  private TagDAO tagDAO;

  private EntityChangeDAO entityChangeDAO;

  
  public void setEntityChangeDAO(EntityChangeDAO entityChangeDAO) {
	this.entityChangeDAO = entityChangeDAO;
}

private ContactDAO contactDAO;

	public void setContactDAO(ContactDAO contactDAO) {
		this.contactDAO = contactDAO;
	}

  /**
   * Get default TagManager as defined in Spring's configuration file.
   * @return the default singleton TagManager
   */
  public static TagManager getDefault()
  {
    return (TagManager)SpringUtils.getSpringBean("managerTag");
  }

  /** 
   * Empty constructor needed by CGLIB (Spring AOP)
   */
  protected TagManager()
  {
  }
	
  /** 
   * Default constructor 
   * @deprecated do not construct managers alone: use Spring's declared beans
   */
  public TagManager( TagDAO tagDAO )
  {
    this.tagDAO = tagDAO;
  }

  /**
   * List tags. 
   * @param search search filter to apply
   * @param sort sorting criteria
   * @return the list of all tags sorted by requested criterion
   */
  public List<Tag> getAllEntities(TagSearch search, SortCriteria sort){
    return tagDAO.search( search, sort );
  }
  
  /**
   * Get tag by primary key.
   * @return tag selected by id.
   */
  public Tag getEntityById(int id){
    final Tag tag = tagDAO.getById(id);
    //tag.initChanges();
    return tag;
  }
	
  /**
   * Insert tag. 
   */
  public void insertEntity(Tag tag) {
	// tracking positions
		trackPositionChanges(tag);
        
	
    tagDAO.insert(tag);
    
    
    
    this.trackContactChanges(tag);
 
  }
	 
  /**
   * Update tag. 
   */
  public void updateEntity(Tag tag) {
	// tracking positions
		trackPositionChanges(tag);
        this.trackContactChanges(tag);
		tagDAO.update(tag);
	}

    private void trackContactChanges(Tag tag) {
		// tracking associated Contacts
		for (Contact contact : tag.getContactTags()) {
            final Contact contactBD = ContactManager.getDefault().getEntityById(contact.getId());
			if (!contactBD.getTags().contains(tag)) {
				//FIXME aqui debería bastar con añadir el cambio o el tag al contacto y salvar el contacto
				//para que se actualizase con los listener de hibernate. Por algún motivo, sólo cuando se da de alta
				//una nueva clave y se asocia a un contacto antes de guardar no funciona correctamente.
				EntityChange entityChange = contactBD.getEntityChange(Contact.FIELD_TAGS, "", tag.getName(),tag.getId().toString());
				contactBD.addEntityChange(Contact.FIELD_TAGS, "", tag.getName(),tag.getId().toString());
//					contactDAO.update(contactBD);
				
				if(entityChange!=null){
					entityChangeDAO.insert(entityChange);
					contactBD.notifyChanges();
				}
                
			}
		}
		// tracking deassociated Contacts
		if (tag.getId() != null) {
			Tag tagDB = getEntityById(tag.getId());
			for (Contact contactDB : tagDB.getContactTags()) {
				if (!tag.getContactTags().contains(contactDB)) {
                    contactDB.addEntityChange(Contact.FIELD_TAGS, tag.getName(), "",tag.getId().toString());
                    contactDAO.update(contactDB);
				}
            }
		}
 }

	private void trackPositionChanges(Tag tag) {
		// tracking associated Positions
		for (Position position : tag.getPositionTags()) {
			Position positionDB = PositionManager.getDefault().getEntityById(position.getId());
			if (!positionDB.getTags().contains(tag)) {
				positionDB.getHistory().add(
						PositionManager.getDefault().getChange(positionDB, PositionManager.FIELD_TAGS, "",
								tag.getName()));
			}
		}
		// tracking deassociated Positions
		if (tag.getId() != null) {
			Tag tagDB = getEntityById(tag.getId());
			for (Position positionDB : tagDB.getPositionTags()) {
				if (!tag.getPositionTags().contains(positionDB)) {
					positionDB.getHistory().add(
							PositionManager.getDefault().getChange(positionDB, PositionManager.FIELD_TAGS,
									tag.getName(), ""));
				}
		}
	}
  }

  /**
   * Delete tag. 
   */
  public void deleteEntity(Tag tag) {
	  // for Position tracking
		tag.getPositionTags().clear();
        tag.getContactTags().clear();
		trackPositionChanges(tag);
        trackContactChanges(tag);
	
    tagDAO.delete(tag);
  }

/* Tag - generated by stajanov (do not edit/delete) */
}
